<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="/stylesheets/print.css" media="print">

    <title>{{blogname}}--编译原理语法制导翻译技术</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>编译原理语法制导翻译技术</h1>
        <h2>{{ subtitle }}</h2>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
		<a id="blog" class="anchor" href="/" aria-hidden="true">
			<span aria-hidden="true" class="octicon octicon-link">INDEX</span>
		</a>
		</h1>
		<h1 id="_1">语法制导翻译技术</h1>
<h4 id="_2">编译程序要求源程序和目标程序具有等价语义,所以需要检查每个语法单位的静态语义.</h4>
<h4 id="_3">实践证明,必须使用形式化的语言和方法精确解释程序设计语言,这种需求产生了形式语义学,分为操作语义,指称语义和公理语义三类</h4>
<p>任何形式化说明方法都必须是完备和统一的</p>
<ul>
<li>操作语义:着重模拟数据加工过程中计算机系统的操作</li>
<li>指称语义:主要描述数据加工的结果</li>
<li>公理语义:通过描述程序执行对程序断言的影响来定义程序\语句\语言结构的语义,主要用于程序正确性证明.</li>
</ul>
<h4 id="_4">语法制导翻译技术:半结构化,属性文法,多数编译程序普遍采用</h4>
<ol>
<li>根据产生式包含的语义,分析文法中每个符号的语义</li>
<li>把这些语义以属性形式附加到相应文法符号上</li>
<li>根据产生式语义,给出符号间属性的求值规则,从而形成语法制导定义</li>
<li>在语法分析中使用该产生式时,根据语义规则对相应的属性进行求值,从而完成翻译</li>
</ol>
<p>进一步
1. 用一个或多个子程序(称为语义动作)的功能来描述产生式语义
2. 把语义动作插入到适当位置形成翻译方案</p>
<p>常用的语法制导翻译过程:</p>
<ol>
<li>根据基础文法对输入符号串进行语法分析,建立语法分析树</li>
<li>根据分析树构造描述各结点属性间依赖关系的有向图</li>
<li>对依赖图进行拓扑排序,得到语义规则的计算次序</li>
<li>按照此顺序对语义规则进行计算,完成预定翻译</li>
</ol>
<p>某些语法制导定义可以在单遍扫描中完成,不需要显式的分析树和构造依赖图</p>
<ul>
<li>语法制导定义是对翻译的高层次说明,隐藏了一些细节,比如语义规则的计算次序</li>
</ul>

      </section>
    </div>

    
  </body>
</html>
